---
title: "Re: Rolling Hash のおはなし"
emoji: "💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AtCoder", "競技プログラミング"]
published: false
---

はじめまして。 maguro (Twitter: [@maguro3260](https://twitter.com/maguro3260)) です。

競技プログラミングをしているときに Rolling Hash について Google で検索すると、[昔自分が書いた記事](https://www.npca.jp/magazine/2021/maguro) が割と上位に出てきたのですが、誤植や不親切な記述が多い^[「校閲入ってないの？」と思われてしまいますが、小冊子にのる簡略バージョンは顧問による校閲が入るのですが、本編は入りません。なので誤植をあってもそのままネットに載ってしまうことがあります。]上に、記事を編集して反映するのは困難だったのでもう一度書き直そうと思います。

# 導入

次の問題を考えてみます。

> **文字列の完全一致検索問題**
>
> $N$ 文字の英小文字からなる文字列 $S$ が与えられます。
> $S$ の連続する部分文字列のうち、長さ $M$ の文字列 $T$ と等しくなるものは存在するでしょうか？存在しないなら $-1$ を、存在するならその文字列が $S$ の先頭から何番目から始まっているかを全て小さい順に答えるプログラムを作成してください。
>
> **制約**
>
> - $1 \leq M \leq N \leq 10^6$
> - $S, T$ は英小文字からなる。

例をあげると、 $S$ が `abracadabra` 、 $T$ が `ab` だったとき、 1, 9 が答えです。もし $T$ が `bba` だったときは $S$ に `bba` は含まれていないので答えは -1 となります。

まず思い付く解き方としては、 $S$ の $1$ 文字目から $M$ 文字目までが $T$ と一致するか、 $2$ 文字目から $M + 1$ 文字目までが $T$ と一致するか、…というように全探索するものがあります。 

しかし、 $1$ 回の一致判定には工夫を行わないと $O(M)$ かかり、これを $N - M + 1$ 回行うことから、全体としては $\mathrm{worst}\ O(NM)$ かかります。これでは $M, N$ が $10^6$ のように大きいと答えを出すのに約 2 年かかってしまいます。

:::message alert
ここは要出典です
:::

しかし、 Rolling Hash を用いると、前計算 $O(N)$ 、 $1$ 回の一致判定を $O(1)$ で行うことができ、全体として $O(N)$ でこの問題を解くことができます。

# Rolling Hash ってなに？

Rolling Hash とは、**「文字列を 1 つの大きな数字として見る」** というアイデアを用いて、文字列検索や一致判定を高速に行うアルゴリズムです。ここでの「1 つの大きな数字」が **ハッシュ** と言われるものです。ハッシュの値をハッシュ値といいます。

ただ、いきなり文字列を数字として扱うのは難しいので、もう少し簡単にした問題を考えてみましょう。

> **数字の一致問題**
>
> $N$ 文字の $1$ 以上 $9$ 以下の数字からなる文字列 $S$ が与えられます。
> $S$ の連続する部分文字列のうち、 $M$ の正の整数 $T$ と等しくなるものは存在するでしょうか？もし存在しないなら $-1$ を、存在するならばその文字列が $S$ の先頭から何番目から始まっているかを全て小さい順に答えるプログラムを作成してください。
>
> 制約
> - $1 \leq M \leq N \leq 10^6$
> - $S, T$ の各桁は $1$ 以上 $9$ 以下からなる

例をあげると、 $S$ が `1234567891234` 、 $T$ が `23` だったときは、 2, 11 が答えです。もし $T$ が `321` だったときは $S$ に `321` は含まれていないので答えは -1 となります。

ここで、 $S$ の連続する部分列 $S'$ に対して、 $S'$ のハッシュ値を **$S'$ を $10$ 進法の整数とみなしたときの値** とすると、 $S'$ のハッシュ値と $T$ のハッシュ値が等しければ $S'$ と $T$ は等しくなります。あとはハッシュ値を高速に計算することができたらこの問題は解けそうです。どうやって解くのでしょうか？

# ハッシュ値の計算

上の問題で $S = 123456789$ の場合を考えます。
また、 $S$ の $a$ 文字目から $b$ 文字目の前までのハッシュ値を $\mathrm{hash}[a][b]$ と書くことにします (文字列の数え方は 0-based index です)。 また、便宜上 $\mathrm{hash}[a][a] = 0$ であるとします。今回の場合、 $\mathrm{hash}[0][3] = 123$ 、 $\mathrm{hash}[1][4] = 234$ 、 $\mathrm{hash}[6][6] = 0$ となります。

ここで $\mathrm{hash}[2][6]$ を $\mathrm{hash}[0][i] (0 \leq i \leq N)$ を使って計算することを考えると、 $\mathrm{hash}[0][2] = 12$ 、 $\mathrm{hash}[0][6] = 123456$ から $\mathrm{hash}[2][6] = \mathrm{hash}[0][6] - \mathrm{hash}[0][2] \times 10^4$ であることが分かります。これを一般に拡張すると $\mathrm{hash}[a][b] = \mathrm{hash}[0][b] - \mathrm{hash}[0][a] \times 10^{b - a}$ が成り立ちます。この式に出てくる $10$ のことをハッシュの基数と言うことにします。

なので、 $\mathrm{hash}[0][i]\ (0 \leq i \leq N)$ を事前に計算しておくと、どんなハッシュを求めるクエリが与えられても $O(1)$ で答えることができます。

ここで、 $S$ の $j$ 文字目を $S_j$ とおくと、

$$
\mathrm{hash}[0][i] = 
\left \{
\begin{array}{l}
0 && (i = 0) \\
\mathrm{hash}[0][i - 1] \times 10 + S_{i - 1} && (1 \leq i \leq N)
\end{array}
\right.
$$

が成り立つことが分かります。これを用いると $\mathrm{hash}[0][i]\ (0 \leq i \leq N)$ を $O(N)$ で求められます。よって、前計算 $O(N)$ 、一致判定 $O(1)$ で数字の一致問題を解くことができました。

文字列の完全一致検索問題に戻ってみましょう。この問題は、数字の一致問題で出てきた $S$ が数字から英小文字で構成されるようになっています。ここで、数字の一致問題の解法を $10$ 進法から $27$ 進法に変えるとどうでしょうか。仮に、 $a = 1,\ b = 2,\ \dots,\ z = 26$ として、ハッシュの基数を $27$ にすると、解法はほとんど一緒であることが分かります (なぜここで $a = 0$ としなかったか、そもそもどうして数字の一致問題で $0$ を含まなかったのかは、すぐ後で説明します。) 

# ハッシュの衝突と回避法

ここまでハッシュはそのまま扱ってきましたが、このままだとハッシュ値の最大値が $27^{10^6} - 1 \fallingdotseq 10^{1.4 * 10^5}$ になり、このような桁の数字を扱うのは困難です^[扱えなくはないですが、数字の各種演算に時間がかかってしまうため非効率です]。そこで、多くの場合ハッシュ値はある整数 $m$ で割った余りにすることが多いです (この $m$ のことを**法**といいます)。

:::message alert
ここ要出典
:::

しかし、ここで問題が発生します。それが**ハッシュの衝突**です。

ハッシュの衝突とは、本来異なっている文字列が同じハッシュを取ることです。仮にあるサービスのパスワード判定がハッシュの一致で行われていたとします。ハッシュが簡単に衝突してしまうと、パスワードが破られて個人情報が流出するなんてことが起こります。なのでハッシュの衝突はなるべく避けないといけません。

そこで、なるべく衝突を回避し、かつプログラムが高速に動作するために以下のような工夫が存在します。

## $0$ が割り当てられるような文字を作らない

上の問題の解法で $a = 0$ としなかったのは、 $a = 0$ とすると $ba$ と $baaa$ は等しいハッシュ値になります。なのでこれは避けないといけません。

## $m$ をなるべく大きくする

ハッシュ値は全て $m$ で割った余りになるので、必ず $1$ 以上 $m - 1$ 以下になります^[$0$ が割り当てられるような文字を作らない上、基本的に基数は法よりも小さいため、ハッシュ値が $m$ の倍数 になることはありません。]。よって、 $m$ 個以上のハッシュを生成した場合、必ずどこかのハッシュ同士が衝突してしまいます。そのため、 $m$ はなるべく大きくする必要があります。

また、ハッシュが $1$ 以上 $m - 1$ 以下のランダムな値をとるとき、ハッシュが衝突する確率は想像以上に高くなります。

[誕生日攻撃 - Wikipedia](https://ja.wikipedia.org/wiki/%E8%AA%95%E7%94%9F%E6%97%A5%E6%94%BB%E6%92%83) にあるように、 $m$ が $32$ ビット (すなわち $2^{32} - 1 \fallingdotseq 4.3 \times 10^9)$ のとき、 $10^5$ のハッシュを生成するだけで衝突する確率が $75\%$ 程度あることが分かります。

$m$ が $64$ ビット (約 $1.84 \times 10^{19}$) のときでも、 $7.2 \times 10^9$ 個のハッシュを生成すると衝突する確率が $75\%$ 程度ありますが、これ以上 $m$ を増やすと実装がややこしくなったりかえってプログラムの実行時間が長くなったりする可能性があります。記事の最後に掲載している実装は $m$ を $64$ ビットとしています。心配なら $128$ ビットの法を用いると良いでしょう。

## ハッシュの基数をランダムな値にする

Codeforces などのハック^[他人のユーザーが提出しているコードで、間違っているものを見つけた時に、正しくない解答をそのコードが出力するような入力を与えることで、自分の点数を得るシステム。]が存在する競技プログラミングのコンテストでは、いくら法を大きくしたとしても、他の競技者がわざとハッシュを衝突させようとする可能性があります。そこで、これを回避するために、ハッシュの基数を実行時ランダムな値にするという方法があります（法をランダムな値にする方法もありますが、割り算をするときに法が定数だと実行時間が短くすることができます）。これで、ハッシュの衝突を意図的に起こすのは難しくなります。

## 法を $2$ のべき乗にしない

先ほど「法を乱数にするとハッシュの衝突を意図的に起こすのは難しくなる」という話をしましたが、法が $2$ のべき乗の時は話が別です。このとき、ハッシュの基数がランダムな値でも、意図的に非常に高い確率でハッシュを衝突させることができます。

他にもいろいろ気を付けないといけないことがありますが、もっと詳しい話は [Rolling Hashを殺す話](https://www.slideshare.net/nagisaeto/rolling-hash-149990902) などを参照してください。

# 応用

## ハッシュ値の結合
